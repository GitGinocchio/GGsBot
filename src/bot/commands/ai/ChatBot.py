from nextcord import (
    Embed,
    Color,
    utils,
    Thread,
    Permissions,
    Interaction,
    SlashOption,
    slash_command,
    ChannelType,
    TextChannel,
    Message
)
from jinja2 import Environment, FileSystemLoader
from datetime import datetime, timezone
from nextcord.ext import commands
#from PIL import Image
import numpy as np
import requests
import nextcord
import base64
import struct
import json
import os
import io

from utils.terminal import getlogger
from utils.commons import (
    Extensions,
    USER_INTEGRATION,
    GUILD_INTEGRATION,
    GLOBAL_INTEGRATION,
    getsession,
    asyncget
)
from utils.db import Database
from utils.exceptions import *
from utils.config import (
    config, 
    DEVELOPER_GUILD_ID
)

logger = getlogger()

templates = [template for template in os.listdir(config["paths"]["chatbot_templates"])]

txt2txt_models = [
    '@cf/meta/llama-3-8b-instruct',
    '@hf/thebloke/llama-2-13b-chat-awq',
    '@cf/mistral/mistral-7b-instruct-v0.1',
    '@hf/google/gemma-7b-it',
    '@hf/nexusflow/starling-lm-7b-beta',
    '@cf/tinyllama/tinyllama-1.1b-chat-v1.0',
]

permissions = Permissions(
    use_slash_commands=True
    #administrator=True
)

class ChatBot(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.db = Database()
        self.bot = bot

    # NOTE: For now this set of commands are only available in the dev guild.
    @slash_command('chat',"An AI chatbot powered by LLMs (Large Language Models)",default_member_permissions=permissions,integration_types=GUILD_INTEGRATION, guild_ids=[DEVELOPER_GUILD_ID])
    async def chat(self, interaction : Interaction): pass

    @slash_command('ask',description="Ask a question to GG'sBot AI",default_member_permissions=permissions,integration_types=GLOBAL_INTEGRATION, guild_ids=[DEVELOPER_GUILD_ID])
    async def ask(self,
                  interaction : Interaction,
                  prompt : str = SlashOption("prompt","The question you want to ask",required=True),
                  model : str = SlashOption("aimodel","Choose the Artificial Intelligence model you want to use",required=False,choices=txt2txt_models,default=txt2txt_models[0]),
                  #template : str | None = SlashOption("template","Templates are used to get more specific answers for the type of context you want to get.",required=False,choices=templates,default=None),
                  #tags: str = SlashOption("tags","Write separated comma Tags used to get more specific answers",required=False,default=''),
                  ephemeral : bool = SlashOption(description="Whether the response should be ephemeral or not",required=False,default=True),
                ):
        try:
            await interaction.response.defer(ephemeral=ephemeral)
            url = f"https://gateway.ai.cloudflare.com/v1/{os.environ['CLOUDFLARE_ACCOUNT_ID']}/ggsbot-ai"
            headers = { "Authorization": f"Bearer {os.environ['CLOUDFLARE_API_KEY']}", 'Content-Type': 'application/json' }
            data = [
                {
                    "provider": "workers-ai",
                    "endpoint": model,
                    "headers" : headers,
                    "query": {
                        "messages": [
                            { "role" : "system", "content" : "The user will ask you a question, answer in the same language, give your opinion on the topic discussed, you must be concise" },
                        ],
                        "prompt" : { "role": "user", "content": prompt }
                    }
                }
            ]

            content_type, content, status, reason = await asyncget(url, headers=headers, data=data)
            if status != 200: 
                raise GGsBotException(
                    title="Cloudflare API Exception", 
                    description=f"An error occurred in cloudflare API (status: {status}): {reason}"
                )
            content : dict = json.loads(content)

            if not content['success']: raise CloudFlareAIException(code=content['errors'][0]['code'])
            result : str = content['result']['response']

            max_length = 1000
            message = f"\n\n**[Create a chat to have answers longer than {max_length} characters]**"

            if len(result) > max_length:
                text_limit = max_length - len(message)
                result = result[:text_limit] + message

            embed = Embed(
                title=f"{prompt}",
                description=f"{result}",
                color=Color.green(),
                timestamp=datetime.now(timezone.utc)
            )
            embed.add_field(name="Model:", value=f"**{model}**", inline=True)
            embed.set_footer(
                text=f"Generated by {self.bot.user.name} powered by Cloudflare Ai Workers", 
                icon_url="https://static-00.iconduck.com/assets.00/cloudflare-icon-512x512-c1lpcyo0.png"
            )
            embed.set_author(name=interaction.user.name,icon_url=interaction.user.avatar.url if interaction.user.avatar else interaction.user.default_avatar.url)

            await interaction.followup.send(embed=embed)
        except CloudFlareAIException as e:
            await interaction.followup.send(embed=e.asEmbed())
            logger.error(e)

    @chat.subcommand('new',"Create a chat with GG'sBot Ai")
    async def newchat(self, 
        interaction : Interaction,
        public : bool = SlashOption('public','Whether the chat between you and the bot should be public or private',required=True,default=False),
        aimodel : str = SlashOption("aimodel","Choose the Artificial Intelligence model you want to use",required=True,choices=txt2txt_models,default=txt2txt_models[0]),
        template : str | None = SlashOption("template","Templates are used to get more specific answers for the type of context you want to get.",required=False,choices=templates,default=None),
        tags: str = SlashOption("tags","Write separated comma Tags used to get more specific answers",required=False,default=''),
        max_tokens : int = SlashOption("max_tokens", "The maximum number of tokens to generate in the response. (default: 256, min: 32, max: 2048)", required=False, default=256, max_value=2048, min_value=32),
        temperature : float = SlashOption("temperature", "Controls the randomness of the output. (default: 0.6, min: 0, max: 5)", required=False, default=0.6, min_value=0.0, max_value=5.0),
        top_p : float = SlashOption("top_p", "Adjusts the creativity of the AI's responses. (min: 0, max: 2)", required=False, default=None, min_value=0.0, max_value=2.0),
        top_k : int = SlashOption("top_k", "Limits the AI to choose from the top 'k' most probable words. (min: 1, max: 50)", required=False, default=None, min_value=1, max_value=50),
        r_penalty : float = SlashOption("repetition_penalty", "Penalty for repeated tokens; higher values discourage repetition. (min: 0, max: 2)", required=False, default=None, min_value=0.0, max_value=2.0),
        f_penalty : float = SlashOption("frequency_penalty", "Decreases the likelihood of the model repeating the same lines verbatim. (min: 0, max: 2)", required=False, default=None, min_value=0.0, max_value=2.0),
        p_penalty : float = SlashOption("presence_penalty", "Increases the likelihood of the model introducing new topics. (min: 0, max: 2)", required=False, default=None, min_value=0.0, max_value=2.)
    ):
        await interaction.response.defer(ephemeral=True)

        try:

            async with self.db:
                config, enabled = await self.db.getExtensionConfig(interaction.guild, Extensions.AICHATBOT)
            if not enabled: raise ExtensionException("Not Enabled")

            if interaction.channel.id not in config['allowed-channels']: raise SlashCommandException("Invalid Channel")

            thread : Thread = await interaction.channel.create_thread(
                name="New Chat",
                reason=f'<@{interaction.user.id}> created a GG\'Bot AI chat',
                type=ChannelType.public_thread if public else ChannelType.private_thread
            )
            await thread.edit(slowmode_delay=config['chat-delay'])
            await thread.add_user(interaction.user)

            config['threads'][str(thread.id)] = {
                'template' : template,
                'aimodel' : aimodel,
                'creator' : interaction.user.name,
                'creator-mention' : interaction.user.mention,
                'max-tokens' : max_tokens,
                'temperature' : temperature,
                'top-p' : top_p,
                'top-k' : top_k,
                'r-penalty' : r_penalty,
                'f-penalty' : f_penalty,
                'p-penalty' : p_penalty,
                'tags' : tags
            }

            async with self.db:
                await self.db.editExtensionConfig(interaction.guild, Extensions.AICHATBOT, config)
        except (ExtensionException, SlashCommandException) as e:
            await interaction.followup.send(embed=e.asEmbed())
        except DatabaseException as e:
            logger.error(str(e))
        else:
            await interaction.followup.send("Chat created successfully")

    @chat.subcommand('del',"Delete a chat with GG'sBot Ai")
    async def delchat(self, interaction : Interaction):
        try:
            await interaction.response.defer(ephemeral=True)

            async with self.db:
                config, enabled = await self.db.getExtensionConfig(interaction.guild,Extensions.AICHATBOT)
            if not enabled: raise ExtensionException("Not Enabled")

            if not str(interaction.channel.id) in config['threads']: raise SlashCommandException("Invalid Channel")

            await interaction.channel.delete()
            config['threads'].pop(str(interaction.channel.id))

            async with self.db:
                await self.db.editExtensionConfig(interaction.guild, Extensions.AICHATBOT, config)

        except (SlashCommandException, ExtensionException) as e:
            await interaction.followup.send(embed=e.asEmbed())
            logger.error(e)

    @commands.Cog.listener()
    async def on_message(self, message : Message):
        try:

            if message.author ==  self.bot.user: return
            if not self.bot.user.mentioned_in(message) and not any(role.name == self.bot.user.name for role in message.role_mentions): return

            async with self.db:
                config, enabled = await self.db.getExtensionConfig(message.guild,Extensions.AICHATBOT)
            if not enabled: return

            if not str(message.channel.id) in config['threads']: return

            thread_config = config['threads'][str(message.channel.id)]

            template_name = thread_config['template']
            creator = thread_config['creator']
            creator_mention = thread_config['creator-mention']
            model = thread_config['aimodel']
            max_tokens = thread_config['max-tokens']
            temperature = thread_config['temperature']
            top_p = thread_config['top-p']
            top_k = thread_config['top-k']
            r_penalty = thread_config['r-penalty']
            f_penalty = thread_config['f-penalty']
            p_penalty = thread_config['p-penalty']
            tags = thread_config['tags']

            url = f"https://gateway.ai.cloudflare.com/v1/{os.environ['CLOUDFLARE_ACCOUNT_ID']}/ggsbot-ai"
            headers = { "Authorization": f"Bearer {os.environ['CLOUDFLARE_API_KEY']}", "Content-Type": "application/json" }
            data = [{
                "provider": "workers-ai", 
                "headers" : headers, 
                "endpoint": model, 
                "query": { 
                    "messages": [],
                    "prompt" : {
                        "prompt": message.clean_content,
                        "max_tokens" : max_tokens,
                        "temperature" : temperature,
                    }
                }
            }]
            if top_p: data[0]['query']['prompt']['top_p'] = top_p
            if top_k: data[0]['query']['prompt']['top_k'] = top_k
            if r_penalty: data[0]['query']['prompt']['repetition_penalty'] = r_penalty
            if f_penalty: data[0]['query']['prompt']['frequency_penalty'] = f_penalty
            if p_penalty: data[0]['query']['prompt']['presence_penalty'] = p_penalty

            if template_name:
                developer = await self.bot.fetch_user(os.environ['DEVELOPER_ID'])

                jinjaenv = Environment(loader=FileSystemLoader('data/chatbot-templates'), autoescape=True)
                template = jinjaenv.get_template(template_name)
                template_content = template.render({
                    'name' : self.bot.user.name,
                    'discriminator' : self.bot.user.discriminator,
                    'developer' : developer.mention,
                    'creator_mention' : creator_mention,
                    'creator' : creator,
                    'tags' : tags,
                })

                data[0]['query']['messages'].append(
                    {
                        "role":  "system",
                        "content": template_content
                    }
                )

            async for history_message in message.channel.history(limit=25,oldest_first=False):
                if history_message.clean_content == '': continue
                data[0]['query']['messages'].append(
                    {
                        "role": "user" if history_message.author.name != self.bot.user.name else "assistant",
                        "content": history_message.clean_content
                    }
                )
            data[0]['query']['messages'] = data[0]['query']['messages'][::-1]

            response = await message.reply("Sto formulando una risposta...")

            print(data)
        
            content_type, content, status, reason = await asyncget(url, json=data)
            if status != 200: 
                raise GGsBotException(
                    title="Cloudflare API Exception", 
                    description=f"An error occurred in cloudflare API (status: {status}): {reason}"
                )

            content : dict = json.loads(content)

            if not content['success']:
                raise GGsBotException(
                    title="Cloudflare API Exception",
                    description=f"An error occurred in cloudflare API (code:{content['errors'][0]['code']}): {content['errors'][0]['message']}",
                    suggestions=f"Please try again later or contact support for further assistance"
                )

            result : str = content['result']['response']

            await self.send_chunks(result, message.channel, response)
        except TimeoutError as e:
            await response.edit(content="Request took to long to execute. Please try again later.")
        except Exception as e:
            logger.error(e)

    async def send_chunks(self, text : str, channel : TextChannel, first_message : Message):
        current_text = ''
        chunks = text.split('```')
        for n, chunk in enumerate(chunks,0):
            for line in chunk.split('\n'):
                if len(current_text + line + '\n') < 2000:
                    current_text += line + '\n'
                else:
                    if n == 0: 
                        await first_message.edit(content=current_text)
                    elif n % 2 != 0:
                        await channel.send(content=f'```{current_text}```')
                    else:
                        if current_text:
                            await channel.send(content=current_text)
                    current_text = line + '\n'
            
            if current_text: 
                if n == 0:
                    await first_message.edit(content=current_text)
                elif n % 2 != 0:
                    await channel.send(content=f'```{current_text}```')
                else:
                    await channel.send(content=current_text)
                current_text = ''

def setup(bot: commands.Bot):
    bot.add_cog(ChatBot(bot))